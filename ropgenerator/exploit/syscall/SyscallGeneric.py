# -*- coding:utf-8 -*- 
# Syscall module:  structure and build function for syscalls
from enum import Enum
from ropgenerator.exploit.ChainingUtils import call_function, set_multiple_regs, _hexify_string
from ropgenerator.core.IO import verbose, str_bold, str_ropg, str_payload, error, str_special, verbose
from ropgenerator.core.ChainingEngine import *
from ropgenerator.core.Architecture import *

class ArgType(Enum):
    INT="int"
    STRING="str"
    INT_OR_STRING="int or str"
    
def verify_arg_type(arg, argType):
    if( argType == ArgType.INT ):
        return isinstance(arg, int)
    elif( argType == ArgType.STRING ):
        return isinstance(arg,str)
    elif( argType == ArgType.INT_OR_STRING):
        return isinstance(arg,str) or isinstance(arg, int)
    else:
        return False

class Syscall:
    def __init__(self, ret_type_str, name, def_args, arg_types, arg_regs, syscall_arg_regs, function=None):
        if( not function):
            function = name
        self.ret = ret_type_str
        if( function ):
            self.def_function = function # Function corresponding to the syscall
        else:
            self.def_function = name
        self.def_name = name
        self.def_args = def_args  # Type and name of arguments as couple of strings (type, name)
        self.arg_regs = arg_regs # Registers nums to put arguments in 
        self.arg_types = arg_types # Type of arguments 
        self.syscall_arg_regs = syscall_arg_regs # List of couples (reg_num,value) to be set to do the syscall
        
        
    def __str__(self):
        res = self.ret + " " + str_bold(self.name())
        res += "("
        res += ', '.join([a[0] + " " + str_special(a[1]) for a in self.def_args])
        res += ")"
        return res
    
    def name(self):
        return self.def_name
        
    def function(self):
        return self.def_function
        
    def nb_args(self):
        return len(self.arg_regs)
        
    def build(self, args, params, system, chainable=False):
        """
        params: SearchParameterBindings
        args: list of args (int or string)
        
        return: error string or ROPChain
        """
        # Check args
        if( self.nb_args() != len(args)):
            return "Error. Expected {} arguments, got {}".format(len(self.arg_types), len(args))
        # Check args length 
        for i in range(0,len(args)):
            if( not verify_arg_type(args[i], self.arg_types[i])):
                return "Argument error for '{}': expected '{}', got '{}'".format(args[i], self.arg_types[i], type(args[i])) 
        
        # A. -------------------- Check if we have the function
        verbose("Trying to call {}() function".format(self.def_name))
        func_call_res = call_function(self.function(), args, params, system)
        if( isinstance(func_call_res, str) ):
            verbose(func_call_res)
        elif(func_call_res is None ):
            verbose("Coudn't call {}()".format(self.function()))
        else:
            verbose("Success")
            return func_call_res
        
        # B. -------------------- Otherwise do syscall directly
        verbose("Trying direct syscall")
        # Set the registers
        syscall_args = []
        for i in range(0, len(args)):
            # Write a comment for arguments 
            if( isinstance(args[i], str)):
                arg_str = str_ropg(_hexify_string(args[i]))
            else:
                arg_str = str_ropg(hex(args[i]))
            syscall_args.append( ( self.arg_regs[i] , args[i], self.def_args[i][1] + ": " + arg_str) )
        for i in range(0, len(self.syscall_arg_regs)):
            syscall_args.append( (self.syscall_arg_regs[i][0], self.syscall_arg_regs[i][1] ,"syscall number: " + str_ropg(hex(self.syscall_arg_regs[i][1]))) )
        # Search
        set_regs_chain = set_multiple_regs(syscall_args, params, system)
        if( set_regs_chain is None ):
            verbose("Failed to set registers for the syscall")
            return None
        
        
        #Â Remove the chainable constraint as we call syscall last (if chainable is not enforced)
        saved_chainable = params.chainable
        if( not chainable ):
            params.chainable = False
        # Check architecture
        # Int 0x80
        if( curr_arch_type() == ArchType.ARCH_X86 ):
            syscall_chain = search(DestArg(), AssignArg(AssignType.INT80), params)
            if( not syscall_chain.found ):
                verbose("Failed to find a 'int0x80' chain")
        # syscall 
        elif( curr_arch_type() == ArchType.ARCH_X64 ):
            syscall_chain = search(DestArg(), AssignArg(AssignType.SYSCALL), params)
            if( not syscall_chain.found ):
                verbose("Failed to find a 'syscall' chain")
        else:
            return "Error, current architecture not supported for direct syscalls"
        params.chainable = saved_chainable
        if( not syscall_chain.found ):
            return None
        # Success ! 
        verbose("Success")
        res = set_regs_chain
        res.add_chain(syscall_chain.chain)
        return res
